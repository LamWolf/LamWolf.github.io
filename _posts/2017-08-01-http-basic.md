---
layout: post
title: "http那些事儿"
tags:
    - http
    - 前端
date: 2017-08-01 12:00:00
author: "LamWolf"
catalog: true
header-img: "img/post-bg-http.jpg"
---



## 写在前面

作为一名前端开发人员，少不了跟网络活动打交道，而网络最基本的活动之一就是一次次的http请求，那http是什么，http请求又是什么呢？本篇文章，就对http进行一次基础的系统总结。

##目录

1. 什么是http协议？
2. 一次http请求是由哪几部分组成的？
3. http的不同请求方法
4. http的状态码


## 正文从这里开始

### 1.什么是http协议？

>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

上文是维基百科中对于超文本传输协议，即HTTP的定义。HTTP最开始被设计出来的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。

HTTP共经历过0.9,1.0,1.1和2.0（目前最新的版本）共四个版本，HTTP/0.9已被弃用，后文中可能会涉及到部分各HTTP版本的特性，如果想要了解更多关于不同HTTP版本的特性，请自行搜索查阅相关文档。

简单说来，HTTP协议就是双方为了能够完成正常的网络通信而提前做好的一个约定。

### 2.一次http请求是由哪几部分组成的？

##### URL

URL(Uniform/Universal Resource Locator 的缩写，统一资源定位符)属于URL(Uniform Resource Identifier 的缩写，统一资源标识符)更低层次的抽象，是一种字符串文本标准。

也就是说，URI属于父类，而URL属于URI的子类。URL是URI的一个子集。

二者的区别在于，**URI表示服务器的路径，定义这么一个资源**。而**URL同时说明要如何访问这个资源（http://）**。

1. URL的标准格式

	**scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]**

	|名称|意义|
	|----|---|
	|scheme|协议，例如：http,https,ftp,ed2k以及迅雷的thunder等|
	|host|http服务器的ip地址或者域名，例如：192.168.1.1或者www.google.com|
	|port#|http服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口号就需要指明，比如：localhost:8080/|
	|path|访问资源的路径|
	|url-params|所带参数|
	|query-string|发送给服务器的数据|
	|anchor|锚点定位|

2. URL中的特殊字符

	在URL中除了字母还会出现特殊的字符，他们的意义如下：

	|字符|含义|十六进制|
	|---|---|-------|
	|+|表示空格|%2B|
	|/|分隔目录和子目录|%2F|
	|?|分隔实际的URL和参数|%3F|
	|#|表示书签或者锚点|%23|
	|&|URL中指定的参数间的分隔符|%26|
	|=|URL中指定的参数的值|%3D|

	**"#"**的特殊作用（**Hash**）
	
	* **井号在URL中指定的是页面中的一个位置**
		
		井号作为页面定位符出现在URL中，比如：www.google.com/123.html#print(该地址并不存在，乱写的)，此URL表示在123.html页面中的#print位置。浏览器读取到此URL后会自动将print位置滚动到可视区域。
	
	* **井号后面的内容不会发送到http请求中**
	
		原因是井号后面的参数是针对浏览器起作用而不是服务器端。
	
	* **位于井号后面的字符都是位置标识符**

		比如一个地址链接中含有`.../?color=#ffffff`，此参数为颜色，然而服务器解析的参数结果为`.../?color=`
	
	* **改变井号后面的参数不会触发页面的重新加载，但是会留下一个历史记录**

		仅改变井号后面的内容，只会使浏览器滚动到相应的位置，并不会重新加载页面
		
	* **可以通过JavaScript使用window.location.hash来改变井号后面的值**

		window.location.hash这个属性对URL中的井号参数进行修改，基于这个原理，我们可以在不重载页面的前提下创造一天新的访问记录。<br>
		除此之外，H5新增的onhashchange事件，当#值发生变化时，就会触发这个事件。
	
	* **Googlebot对井号的过滤机制**

		默认情况下Google在索引页面的时候会忽略井号后面的参数，同时也不会去执行页面中的javascript。然而谷歌为了支持对Ajax生成内容的索引，定义了如果在URL中使用“#!”，则Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。
		
	井号除了简单的“定位”之外，作用还有很多，甚至可以结合？等元素标记流量来源，更深层次的用法就不在这里深究了，有兴趣可以自行搜索查找相关文档。

3. URL编码

	一个东西需要进行编码，那就说明这个东西是不适合直接传输的。
	
	* **会引起歧义**

		URL参数字符串中使用 key=value 这样的键值对形式来传参，键值对之间以 & 符号分隔，如 ?id=123456&name=abcdef，服务器会根据参数串的 & 和 = 对参数进行解析，如果 value 字符串中包含了 = 或者 & ,比如宝洁公司的简称为P&G，假设要将这个简称作为value值传递，则URL中会出现 ?id=123456&name=P&G，因为参数中多了一个&，会造成服务端解析错误，所以要将value值中的 & 和 = 进行转义，即进行编码。
		
	* **非法字符**

		URL的编码格式是ASCII码，而不是Unicode，这也就是说在URL中不能包含任何非ASCII字符，例如中文。否则如果客户端浏览器和服务端浏览器支持的字符集不同的情况下，中文可能会造成问题。
		
	关于如何进行URL编码就不在本文中进行介绍了，我会另写一篇文章专门来讲述URL的编码方法。
	
	以上内容大部分参考了别人的整理文章，参考文章传送门见文末。
	
<br>

##### http报文

http报文分为**请求报文**和**响应报文**，均由三部分组成，分别是：**起始行**、**首部**、**主体**（也有的叫法是：**请求行**、**消息报头**和**请求正文**）。三部分的名称会有翻译版本的不同，不过内容都是一样的，以下均用第一种名称。

|请求报文|所属部分|响应报文|
|---|---|---|
|格式：Method Request-URI HTTP-Version CRLF<br>例如：GET /test/hi-there.txt HTTP/1.0|起始行|格式：HTTP-Version Status-Code Phrase CRLF<br>例如：HTTP/1.0 200 OK|
|格式：name:[可选的空格]字段值 CRLF(或者换行符)<br>例如：Accept: text/*|首部|格式：不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息<br>例如：Content-type: text/plain|
|请求主体包括了要发送给Web服务器的数据<br>例子略|主体|响应主体中装在了要返回给客户端的数据<br>例如：Hi!I am a message!|

*注释：Method表示请求方法，Request-URI是一个统一资源标识符，HTTP-Version表示请求的HTTP协议版本，CRLF表示回车和换行（除了结尾的CRLF外，不允许出现单独的CR或LF字符）*

1. **起始行**

	http报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。
	
	* **请求行**
	
		请求报文的起始行，或称为请求行，包含了一个**方法**和一个**请求URL**，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。请求行中还包含**HTTP的版本**，用来告知服务器，客户端使用的是哪种HTTP。所有这些字段都由空格符分隔。
	
		例如：POST /infoNewsAction_uploadxheditorfile.action?immediate=1 HTTP/1.1
	
	* **响应行**

		响应报文的起始行，或称为响应行，包含了响应报文使用的HTTP版本、数字状态码，以及描述状态的文本形式的原因短语。所有这些字段都由空格符进行分隔。
		
		例如：HTTP/1.1 200 OK
		
2. **首部（header）**

	HTTP header字段包括**通用头**、**请求头**、**响应头**和**实体头**4个部分。每个header字段由一个字段名、冒号（：）和字段值3部分组成。字段名是大小写无关的，字段值前可以添加任何数量的空格符，header字段可以被扩展为多行，在每行开始出，使用至少一个空格或制表符。
	
	* **通用头**

		通用header字段包含请求和响应消息都支持的header字段：
		
		|首部字段名|说明|
		|---|---|
		|Cache-Control|控制缓存行为|
		|Connection|控制不再转发给代理的首部字段；管理持久连接|
		|Date|创建报文的日期时间|
		|Pragma|是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义，会要求所有的中间服务器不返回缓存的资源，通常会与`Cache-Control`同时使用|
		|Trailer|说明在报文主体后记录了哪些首部字段|
		|Transfer-Encoding|规定传输报文主体所采用的编码方式|
		|Upgrade|用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议|
		|Via|用于追踪客户端和服务器之间的请求和响应报文的传输路径|
		|Warning|告知用户一些与缓存相关问题的警告|
		
	* **请求头**

		请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户短信息、对响应内容相关的优先级等内容。
		
		|首部字段名|说明|
		|---|---|
		|Accept|通知服务器，用户代理能够处理的媒体类型以及媒体类型的相对优先级。可使用`type/subtype`这种形式，一次指定多种媒体类型|
		|Accept-Charset|通知服务器用户代理支持的字符集以及字符集的相对优先顺序；可一次性指定多种字符集|
		|Accept-Encoding|通知服务器用户代理支持的内容编码及内容编码的优先级顺序；可一次性指定多种内容编码|
		|Accept-Language|告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级；可一次性指定多种自然语言集|
		|Authorization|告知服务器，用户代理的认证信息（证书值）|
		|Expect|告知服务器期望出现的某种特定行为|
		|From|告知服务器使用用户代理的用户的电子邮件地址|
		|Host|告知服务器请求的资源所处的互联网主机名和端口号；此字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段|
		|If-xxx|可统称为条件请求，服务器收到附带条件的请求后，只有判断指定条件为真时，才会执行请求（每个if字段的详细内容请自行搜索，就不在这里一一列举了）|
		|Range|对于只需获取部分资源的范围请求，包含该字段即告知服务器资源的指定范围|
		|User-Agent|该字段将创建请求的浏览器和用户代理名称等信息传达给服务器|
		
	* **响应头**

		响应首部字段是由服务器向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息以及对客户端的附加要求等信息。
		
		|首部字段名|说明|
		|---|---|
		|Accept-Ranges|用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源|
		|Age|该字段能告知客户端，源服务器在多久之前创建了响应。字段值的单位为秒（也就是说不能识别毫秒级的判定）|
		|ETag|该字段能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值|
		|Location|可以将响应接收方引导至某个与请求URL位置不同的资源|
		|Proxy-Authenticate|会把由代理服务器所要求的认证信息发送给客户端|
		|Retry-After|告知客户端多久之后再来访问。可为具体的日期时间（Tue Aug 01 2017 10:51:08 GMT+0800 (CST)等格式），也可以是创建响应后的秒数 ETag：120|
		|Server|告知客户端当前服务器上安装的HTTP服务器应用程序的信息|
		|Vary|代理服务器接收到原服务器返回包含Vary指定项的响应之后，若再要进行缓存，仅对请求中含有相同vary指定首部字段的请求返回缓存|
		
		响应首部字段详解传送门[HTTP 响应首部字段（五） - 简书](http://www.jianshu.com/p/a68b5331837a)
		
	* **实体头**

		实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。
		
		|首部字段名|说明|
		|---|---|
		|Allow|用于通知客户端能够支持Request-URI指定资源的所有HTTP方法|
		|Content-Encoding|该字段会告知客户端服务器对实体的主体部分选用的内容编码方式|
		|Content-Language|告知客户端实体主体使用的自然语言，例如：Content-language:zh-CN|
		|Content-Length|表明实体主体部分的大小，单位是字节|
		|Content-Location|该字段给出与报文主体部分相对应的URI|
		|Content-MD5|是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达|
		|Content-Range|针对范围请求，返回响应时使用的该字段，能告知客户端作为响应返回的实体的哪个部分符合范围请求|
		|Content-Type|该字段说明了实体体内对象的媒体类型，字段值格式与Accept字段相同|
		|Expires|该字段会将资源失效的日期告诉客户端|
		|Last-Modified|该字段指明资源最终修改的时间|
		
		
	首部字段详解传送门[HTTP 首部字段详细介绍- 超超boy - 博客园](http://www.cnblogs.com/jycboy/p/http_head.html)
		

3. **http报文其它组成部分**

	http报文除了**起始行**、**首部字段**和**实体**之外，还需要关注的点是**http请求方法**和**状态码**，这两个部分在后文中单独列出总结。
	
### http的不同请求方法

http请求由三部分组成：请求行，消息报头和请求正文。

请求行包含了一个**方法（Method）**和一个请求URL，这个方法（Method）描述了服务器应该执行的操作。请求方法有很多，其中（以HTTP/1.1为准）有四个方法：增（PUT）、删(DELETE)、查(GET)、改(POST)，可以比较形象地描述这些请求方法，当然这只是一个带有比喻性的称呼，它们所起到的作用也比这几个称呼复杂的多。下文将对所有的请求方法进行一个总结。

<br>

##### GET：获取资源

GET方法用来请求已被URI识别的资源。指定的资源经服务器端解析后返回响应内容（也就是说，如果请求的资源是文本，那就保持原样返回;如果CGI[通用网关接口]那样的程序，则返回经过执行后的输出结果）。

最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到URL末尾，以便将信息发送给服务器。

使用GET请求时经常会出现一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名车和值都必须使用encodeURLComponent()进行编码，然后才能放到URL的末尾；而且所有的名-值对都必须由（&）分离，例如：`xhr.open("get","01.php?name=foodoir&age=21",true);`

GET方法最常被拿来与POST方法作比较，两者之间的异同点会在简单介绍完POST之后进行总结，两者的异同点也是这两个方法的关键所在。

<br>

##### POST：传输实体文本

POST方法用来传输实体的主体。

虽然用GET方法也可以用来传输实体的主体，但一般不用GET方法进行传输，而是使用POST方法；虽然GET方法和POST方法很相似，但是POST的主要目的并不是获取响应的主体内容。

POST请求的主体可以包含非常多的数据，而且格式不限。下面举一个例子：`xhr.open("post","01.php",true);`

发送POST请求的第二步就是向send方法中传入某些数据，由于XHR最初的设计是为了处理XML，因此也可以在此处理XML DOM文档，传入的文档经过序列化之后将作为请求主体被提交到服务器。

<br>

##### GET和POST方法的异同点

* GET方法用于信息获取，对于服务端来说，包括数据库的数据来说，GET方法的操作是安全的，不会导致数据等因为错误的操作而造成非法修改，而POST请求是用于修改服务器上资源的请求；
* GET请求的数据会附在URL之后，而POST方法提交的数据则放置在HTTP报文实体的主体里，所以POST方法的安全性（此处的安全性是指信息保密方面的安全）比GET方法要高；
* GET方法传输的数据量一般限制在2KB，其原因在于：GET是通过URL提交数据，而URL本身对于数据没有限制，但是不同的浏览器对于URL是有限制的，比如IE浏览器对于URL的限制为2KB，而Chrome，Firefox浏览器理论上对于URL是没有限制的，它真正的限制取决于操作系统本身；POST方法对于数据大小是无限制的，真正影响到数据大小的是服务器处理程序的能力。

GET和POST是http请求中最常用的两个请求方法，所以这两者之间的异同点是需要搞清楚的，大概说来就是，GET请求只能用在查询信息，需要修改服务端数据的时候才使用POST，当然这也不是绝对的，具体的还要根据实际情况，根据两个方法的特性来选择。

<br>

##### HEAD：获得报文首部

HEAD方法与GET方法一样，只不过不返回报文的主体部分，**用于确认URI的有效性及资源更新的日期时间等**。

具体来说：1、判断类型；2、查看响应中的状态码，看对象是否存在（响应：请求执行成功了，但无数据返回）；3、测试资源是否被修改过

HEAD方法和GET方法的区别：GET方法有实体，HEAD方法无实体。

<br>

##### PUT：传输文件

PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般不用。

<br>

##### DELETE：删除文件

指明客户端想让服务器删除某个资源，与PUT方法相反，按URI删除指定资源

<br>

##### OPTIONS：询问支持的方法

OPTIONS方法用来查询针对请求URI指定资源支持的方法（客户端询问服务器可以提交哪些请求方法）

<br>

##### TRACE：追踪路径

客户端可以对请求消息的传输路径进行追踪，TRACE方法是让web服务器端将之前的请求通信还给客户端的方法

<br>

##### CONNECT：要求用隧道协议连接代理

CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。
		
### http的状态码

在前文关于http报文组成中有提到过，响应报文的起始行中有一个字段是`Status-Code`，即状态码。不同的状态码代表了不同的响应状态，状态码也常常用在回调函数的判定中。状态码的种类很多，一些最基本最常见的状态码需要记住，其它的也建议看一下，总会用到的。

状态码由3位数字组成，表示请求是否被理解或被满足。

状态码的第一个数字定义了响应的类别，后面两位没有具体的分类。

第一个数字有五种可能的取值：

* 1xx：指示信息——表示请求已接收，继续处理。
* 2xx：成功——表示请求已经被成功接收、理解、接受。
* 3xx：重定向——要完成请求必须进行更进一步的操作。
* 4xx：客户端错误——请求有语法错误或请求无法实现。
* 5xx：服务器端错误——服务器未能实现合法的请求。

下面先列举一些比较常见常用的状态码：

|状态码|状态描述|说明|
|---|---|---|
|200|OK|客户端请求成功|
|304|Not Modified|自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容|
|400|Bad Request|由于客户端请求有语法错误，不能被服务器所理解|
|401|Unauthorized|请求未经授权；这个状态码必须和WWW-Authenticate报头域一起使用|
|403|Forbidden|服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因|
|404|Not Found|请求的资源不存在，例如，输入了错误的URL|
|500|Internal Server Error|服务器发生不可预期的错误，导致无法完成客户端的请求|
|503|Service Unavailable|服务器当前不能处理客户端的请求，在一段时间之后，服务器可能会恢复正常|

接下来列举所有状态码，如有遗漏欢迎指正

1. 1xx（临时响应）

	表示临时响应并需要请求者继续执行操作的状态代码。
	
	|状态码|说明|
	|---|---|
	|100|（继续）请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。|
	|101|（切换协议）请求者已要求服务器切换协议，服务器已确认并准备切换。|
	
2. 2xx（成功）
	
	表示成功处理了请求的状态代码。
	
	|状态码|说明|
	|---|---|
	|200|（成功）服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。|
	|201|（已创建）请求成功并且服务器创建了新的资源。|
	|202|（已接受）服务器已接受请求，但尚未处理。|
	|203|（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一来源。|
	|204|（无内容）服务器成功处理了请求，但没有返回任何内容|
	|205|（重置内容）服务器成功处理了请求，通知客户端重置文档视图，比如清空表单内容、重置canvas状态或者刷新用户界面|
	|206|(部分内容)服务器成功处理了部分GET请求|

3. 3xx（重定向）	
	
	表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
	
	|状态码|说明|
	|---|---|
	|300|（多种选择）针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。|
	|301|（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。|
	|302|（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求|
	|303|（查看其他位置）请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码|
	|304|（未修改）自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。|
	|305|（使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。|
	|307|（临时重定向）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。|
	
4. 4xx（请求错误）

	这些状态代码表示请求可能出错，妨碍了服务器的处理。
	
	|状态码|说明|
	|---|---|
	|400|（错误请求）服务器不理解请求的语法。|
	|401|（未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。|
	|403|（禁止）服务器拒绝请求。|
	|404|（未找到）服务器找不到请求的网页|
	|405|（方法禁用）禁用请求中指定的方法。|
	|406|（不接受）无法使用请求的内容特性响应请求的网页。|
	|407|（需要代理授权）此状态码与401（未授权）类似，但指定请求者应当授权使用代理。|
	|408|（请求超时）服务器等候请求时发生超时。|
	|409|（冲突）服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。|
	|410|（已删除）如果请求的资源已永久删除，服务器就会返回此响应。|
	|411|（需要有效长度）服务器不接受不含有效内容长度标头字段的的请求。|
	|412|（为满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。|
	|413|（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。|
	|414|（请求的URI过长）请求的URI（通常为网址）过长，服务器无法处理。|
	|415|（不支持的媒体类型）请求的格式不受请求页面的支持。|
	|416|（请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此状态代码。
	|417|（未满足期望值）服务器未满足“期望”请求标头字段的要求。|
	
5. 5xx（服务器错误）

	这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
	
	|状态码|说明|
	|---|---|
	|500|（服务器内部错误）服务器遇到错误，无法完成请求。|
	|501|（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。|
	|502|（错误网关）服务器作为网关或代理，从上游服务器收到无效响应。|
	|503|（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。|
	|504|（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求。|
	|505|（HTTP版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。|
	
*注：以上状态码并不完全，还有许多新提出的状态码没有加入进去，网上还没有找到非常完整的新状态码的翻译版本，作者个人能力也有限，暂时还不能做到翻译英文原文。不过会尽快将翻译英文原文提上日程。*
		
## 参考文章
* [超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)（维基百科，传送需要翻墙）
* [【基础进阶】URL详解与URL编码](http://www.cnblogs.com/coco1s/p/5038412.html)
* [URL中“#” “？” &“”号的作用](http://www.cnblogs.com/julin-peng/p/4237791.html)
* [HTTP协议详解（真的很经典）](http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html)
* [http请求的组成部分- 一起走过的日子…… - 博客园](http://www.cnblogs.com/goesby/p/4618982.html)
* 《技术之瞳》  ——电子工业出版社
* [第六章HTTP首部 \| 图解HTTP - GitBook](https://ttop5.gitbooks.io/illustration-http/content/chapter6.html)
* [HTTP请求方法详解- foodoir - 博客园](http://www.cnblogs.com/foodoir/p/5911099.html)
* [HTTP协议状态码详解（HTTP Status Code） - 张善友- 博客园](http://www.cnblogs.com/shanyou/archive/2012/05/06/2486134.html)
* [HTTP response codes \| MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)